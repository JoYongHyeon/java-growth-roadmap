## 스레드를 직접 사용할 때의 문제점

**지금까지 사용해왔던 스레드들을 직접 생성해서 사용하면 다음과 같은 3가지 문제가 있다.**
1. **스레드 생성 시간으로 인한 성능 문제**
2. **스레드 관리 문제**
3. **`Ruunable` 인터페이스의 불편함**
---
### 1. 스레드 생성 비용으로 인한 성능 문제?
**스레드를 사용하려면 먼저 스레드를 생성해야 한다. 그런데 스레드는 다음과 같은 이유로 매우 무겁다.**

- **메모리 할당**: 각 스레드는 자신만의 호출 스택(call stack)을 가지고 있어야 한다. 이 호출 스택은 스레드가
                 실행되는 동안 사용하는 메모리 공간이다. 따라서 스레드를 생성할 때는 이 호출 스택을 위한 메모리를 할당해야 한다.


- **운영체제 자원 사용**: 스레드를 생성하는 작업은 운영체제 커널 수준에서 이루어지며, 시스템 콜을 통해 처리된다. 
                        이는 CPU 와 메모리 리소스를 소모하는 작업이다.


- **운영체제 스케줄러 설정**: 새로운 스레드가 생성되면 운영체제의 스케줄러는 이 스레드를 관리하고 실행 순서를 조정해야 한다.
                         이는 운영체제의 스케줄링 알고리즘에 따라 추가적인 오버헤드가 발생할 수 있다.

(**스레드 하나는 보통 1MB 이상의 메모리를 사용**)


**스레드를 직접 생성하는 작업과 단순히 자바 객체를 하나 생성하는 것은 비교할 수 없을 정도로 큰 차이다.
이런 문제를 해결하려면 생성한 스레드를 재사용하는 방법을 고려할 수 있다.
스레드를 처음 생성할 때를 제외하고는 생성을 위한 시간이 들지 않는다.**
---
### 스레드 관리 문제
서버의 CPU, 메모리 자원은 한정되어 있기 때문에, 스레드는 무한하게 만들 수 없다.
갑자기 사용자들의 요청이 몰려들면 CPU, 메모리 자원이 버티지 못할 것이다.
이런 문제를 해결하려면 우리 시스템이 버틸 수 있는, 최대 스레드의 수 까지만 스레드를 생성할 수 있게 관리해야 한다.

또한
예를들어 애플리케이션을 종료한다고 가정해보자.
이때 안전한 종료를 위해 실행 중인 스레드가 남은 작업은 모두 수행한 다음에 프로그램을 종료하고 싶다거나, 또는 
급하게 종료해야 해서 인터럽트 등의 신호를 주고 스레드를 종료하고 싶다고 가정해보자.
이런 경우에도 스레드가 어딘가에 관리가 되어 있어야한다.
---
### Runnable 인터페이스의 불편함
```java
public interface Runnable {
    void run();
}
```
- **반환 값이 없다**: `run()` 메서드는 반환 값을 가지지 않는다. 따라서 실행 결과를 얻기 위해서는 별도의 메커니즘을 사용해야 한다.
- **예외 처리**: `run()` 메서드는 체크 예외(checked exception)를 던질 수 없다. 체크 예외의 처리는 메서드 내부에서 처리해야 한다.
---
## 정리

이런 문제를 해결하려면 반환 값도 받을 수 있고, 예외도 좀 더 쉽게 처리할 수 있는 방법이 필요하다.
추가로 반환 값 뿐만 아니라 해당 스레드에서 발생한 예외도 받을 수 있다면 더 좋을 것이다.
